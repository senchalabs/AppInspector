<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*

Siesta 2.0.5
Copyright(c) 2009-2013 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/products/siesta/license

*/
<span id='Siesta-Test'>/**
</span>@class Siesta.Test
@mixin Siesta.Test.More
@mixin Siesta.Test.Date 
@mixin Siesta.Test.Function
@mixin Siesta.Test.BDD 

`Siesta.Test` is a base testing class in Siesta hierarchy. Its not supposed to be created manually, instead, the harness will create it for you.

This file is a reference only, for a getting start guide and manual, please refer to &lt;a href=&quot;#!/guide/siesta_getting_started&quot;&gt;Getting Started Guide&lt;/a&gt;.

Please note: Each test will be run in **its own**, completely **isolated** and **clean** global scope (created with the iframe). 
**There is no need to cleanup anything**.

SYNOPSIS
========

    StartTest(function(t) {
        t.diag(&quot;Sanity&quot;)
        
        t.ok($, 'jQuery is here')
        
        t.ok(Your.Project, 'My project is here')
        t.ok(Your.Project.Util, '.. indeed')
        
        setTimeout(function () {
        
            t.ok(true, &quot;True is ok&quot;)
        
        }, 500)
    })    


*/

Class('Siesta.Test', {
    
    does        : [
        Siesta.Util.Role.CanFormatStrings,
        Siesta.Test.More,
        Siesta.Test.Date,
        Siesta.Test.Function,
        Siesta.Test.BDD,
        JooseX.Observable
    ],
    
    
    has        : {
        name                : null,
        
<span id='Siesta-Test-property-url'>        /**
</span>         * @property url The url of this test, as given to the {@link Siesta.Harness#start start} method. All subtests of some top-level test shares the same url.
         */
        url                 : { required : true },
        urlExtractRegex     : {
            is      : 'rwc',
            lazy    : function () {
                return new RegExp(this.url.replace(/([.*+?^${}()|[\]\/\\])/g, &quot;\\$1&quot;) + ':(\\d+)')
            }
        },
        
        assertPlanned       : null,
        assertCount         : 0,
        
        // whether this test contains only &quot;todo&quot; assertions
        isTodo              : false,
        
        results             : {
            lazy    : function () {
                return new Siesta.Result.SubTest({ description  : this.name || 'Root', test : this })
            }
        },
        
        run                 : { required : true },
        startTestAnchor     : null,
        exceptionCatcher    : null,
        testErrorClass      : null,
        
        generation          : function () {
            return Math.random()
        },
        
        parent              : null,
        harness             : { required : true },
        
<span id='Siesta-Test-cfg-isReadyTimeout'>        /**
</span>         * @cfg {Number} isReadyTimeout 
         * 
         * Timeout in milliseconds to wait for test start. Default value is 10000. See also {@link #isReady}  
         */
        isReadyTimeout      : 10000,

        // indicates that a test has thrown an exception (not related to failed assertions)
        failed              : false,
        failedException     : null, // stringified exception
        failedExceptionType : null, // type of exception
        
        // start and end date are stored as numbers (new Date() - 0)
        // this is to allow sharing date instances between different contexts
        startDate           : null,
        endDate             : null,
        lastActivityDate    : null,
        contentManager      : null,
        
        // the scope provider for the context of the test page
        scopeProvider       : null,
        // the context of the test page
        global              : { required : true },
        
        // the scope provider for the context of the test script
        // usually the same as the `scopeProvider`, but may be different in case of using `separateContext` option
        scriptScopeProvider : null,
        
        transparentEx       : false,
        
        needDone            : false,
        isDone              : false,
        
        defaultTimeout      : 15000,
        // a default timeout for sub tests
        subTestTimeout      : null,
        // a timeout of this particular test
        timeout             : null,
        
        timeoutsCount       : 1,
        timeoutIds          : Joose.I.Object,
        idsToIndex          : Joose.I.Object,
        waitTitles          : Joose.I.Object,
        
        
        // indicates that test function has completed the execution (test may be still running due to async)
        processed           : false,
        
        callback            : null,
        
        // Nbr of exceptions detected while running the test
        nbrExceptions       : 0,
        testEndReported     : false,
        
        // only used for testing itself, otherwise should be always `true`
        needToCleanup               : true,
        
        overrideSetTimeout          : false,
        
        originalSetTimeout          : { required : true },
        originalClearTimeout        : { required : true },
        
        sourceLineForAllAssertions  : false,
        
        $passCount                  : null,
        $failCount                  : null
    },
    
    
    methods : {
        
        initialize : function () {
            // suppress bubblings of some events (JooseX.Observable does not provide better mechanism for that, yet)
            this.on('teststart', function (event) {
                if (this.parent) event.stopPropagation()
            })
            
            this.on('testfinalize', function (event) {
                if (this.parent) event.stopPropagation()
            })
            
            this.on('beforetestfinalize', function (event) {
                if (this.parent) event.stopPropagation()
            })
            
            this.on('beforetestfinalizeearly', function (event) {
                if (this.parent) event.stopPropagation()
            })
            
            this.subTestTimeout     = 2 * this.defaultTimeout
        },
        
<span id='Siesta-Test-method-isReady'>        /**
</span>         * This method allows you to delay the start of the test, for example for performing some asynchronous setup code (like login into application).
         * Note, that you may want to use {@link #setup} method instead, as its a bit simpler for implementation.  
         * 
         * It is supposed to be overriden in the subclass of Siesta.Test and should return object with properties &quot;ready&quot; and &quot;reason&quot; 
         * (&quot;reason&quot; is only meaningful for &quot;ready : false&quot;). Test instance will poll this method and will only launch
         * the test, when this method will return &quot;ready : true&quot;. If waiting for this will take longer than {@link #isReadyTimeout} then, test
         * will be launched anyway, but a failing assertion will be added to it.
         * 
         * **Important** This method should always check the value returned by `this.SUPER` call. 
         * 
         * Typical example of using this method will be:
         * 

    Class('My.Test.Class', {
        
        isa         : Siesta.Test.Browser,
            
        has         : {
            isCustomSetupDone           : false
        },
        
        override : {
            
            isReady : function () {
                var result = this.SUPERARG(arguments);
    
                if (!result.ready) return result;
    
                if (!this.isCustomSetupDone) return {
                    ready       : false,
                    reason      : &quot;Waiting for `isCustomSetupDone` took too long - something wrong?&quot;
                }
                
                return {
                    ready       : true
                }
            },
    
            
            start : function () {
                var me      = this;
                
                Ext.Ajax.request({
                    url     : 'do_login.php',
                    
                    params  : { ... },
                    
                    success : function () {
                        me.isCustomSetupDone    = true
                    }
                })
                
                this.SUPERARG(arguments)
            }
        },
        
        ....
    })
    
         * 
         * @return {Object} Object with properties `{ ready : true/false, reason : 'description' }`
         */
        isReady: function() {
            // this should allow us to wait until the presense of &quot;run&quot; function
            // it will become available after call to StartTest method
            // which some users may call asynchronously, after some delay
            // see https://www.assembla.com/spaces/bryntum/tickets/379
            // in this case test can not be configured using object as 1st argument for StartTest
            this.run    = this.run || this.getStartTestAnchor().args &amp;&amp; this.getStartTestAnchor().args[ 0 ]
            
            return {
                ready   : this.typeOf(this.run) == 'Function',
                reason  : 'No code provided to test'
            }
        },
        
        
        isFromTheSameGeneration : function (test2) {
            return this.generation == test2.generation
        },
        

        toString : function() {
            return this.url
        },
        
        
        // deprecated
        plan : function (value) {
            if (this.assertPlanned != null) throw new Error(&quot;Test plan can't be changed&quot;)
            
            this.assertPlanned = value
        },
        
        
        addResult : function (result) {
            var isAssertion = result instanceof Siesta.Result.Assertion
            
            if (isAssertion) result.isTodo = this.isTodo
            
            // only allow to add diagnostic results and todo results after the end of test
            // and only if &quot;needDone&quot; is enabled
            if (isAssertion &amp;&amp; (this.isDone || this.isFinished()) &amp;&amp; !result.isTodo) {
                if (!this.testEndReported) {
                    this.testEndReported = true
                    
                    this.fail(&quot;Adding assertions after the test has finished.&quot;)
                }
            }

            if (isAssertion &amp;&amp; !result.index) {
                result.index = ++this.assertCount
            }

            this.getResults().push(result)
            
            // clear the cache
            this.$passCount     = this.$failCount   = null
            
<span id='Siesta-Test-event-testupdate'>            /**
</span>             * This event is fired when an individual test case receives a new result (assertion or diagnostic message).
             * 
             * This event bubbles up to the {@link Siesta.Harness harness}, so you can observe it on the harness as well.
             * 
             * @event testupdate
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has started
             * @param {Siesta.Result} result The new result. Instance of Siesta.Result.Assertion or Siesta.Result.Diagnostic classes
             */
            this.fireEvent('testupdate', this, result, this.getResults())

            this.lastActivityDate = new Date();
        },
        

<span id='Siesta-Test-method-diag'>        /**
</span>         * This method output the diagnostic message.  
         * @param {String} desc The text of diagnostic message
         */
        diag : function (desc) {
            this.addResult(new Siesta.Result.Diagnostic({
                description : desc
            }))
        },
        
        
<span id='Siesta-Test-method-pass'>        /**
</span>         * This method add the passed assertion to this test.
         * 
         * @param {String} desc The description of the assertion
         * @param {String/Object} annotation The string with additional description how exactly this assertion passes. Will be shown with monospace font.
         * Can be also an object with the following properties:
         * @param {String} annotation.annotation The actual annotation text
         * @param {String} annotation.descTpl The template for the default description text. Will be used if user did not provide any description for
         * assertion. Template can contain variables in braces. The values for variables are taken as properties of `annotation` parameters with the same name:
         * 

    this.pass(desc, {
        descTpl         : '{value1} sounds like {value2}',
        value1          : '1',
        value2          : 'one
    })

         * 
         */
        pass : function (desc, annotation, result) {
            if (annotation &amp;&amp; this.typeOf(annotation) != 'String') {
                // create a default assertion description
                if (!desc &amp;&amp; annotation.descTpl) desc = this.formatString(annotation.descTpl, annotation)
                
                // actual annotation
                annotation          = annotation.annotation
            }
            
            if (result) {
                result.passed       = true
                result.description  = desc || ''
                result.annotation   = annotation
            }
            
            this.addResult(result || new Siesta.Result.Assertion({
                passed          : true,
                
                annotation      : annotation,
                description     : desc || '',
                sourceLine      : (result &amp;&amp; result.sourceLine) || (annotation &amp;&amp; annotation.sourceLine) || this.sourceLineForAllAssertions &amp;&amp; this.getSourceLine() || null
            }))
        },
        
        
<span id='Siesta-Test-method-typeOf'>        /**
</span>         * This method returns a result of `Object.prototype.toString` applied to the passed argument. The `[object` and trailing `]` are trimmed. 
         * 
         * @param {Mixed} object
         * @return {String} The name of the &quot;type&quot; for this object.
         */
        typeOf : function (object) {
            return Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/\]$/, '')
        },
        
<span id='Siesta-Test-method-fail'>        /**
</span>         * This method add the failed assertion to this test.
         * 
         * @param {String} desc The description of the assertion
         * @param {String/Object} annotation The additional description how exactly this assertion fails. Will be shown with monospace font.
         * 
         * Can be either string or an object with the following properties. In the latter case a string will be constructed from the properties of the object.
         * 
         * - `assertionName` - the name of assertion, will be shown in the 1st line, along with originating source line (in FF and Chrome only)
         * - `got` - an arbitrary JavaScript object, when provided will be shown on the next line
         * - `need` - an arbitrary JavaScript object, when provided will be shown on the next line
         * - `gotDesc` - a prompt for &quot;got&quot;, default value is &quot;Got&quot;, but can be for example: &quot;We have&quot; 
         * - `needDesc` - a prompt for &quot;need&quot;, default value is &quot;Need&quot;, but can be for example: &quot;We need&quot;
         * - `annotation` - A text to append on the last line, can contain some additional explanations
         * 
         *  The &quot;got&quot; and &quot;need&quot; values will be stringified to the &quot;not quite JSON&quot; notation. Notably the points of circular references will be 
         *  marked with `[Circular]` marks and the values at 4th (and following) level of depth will be marked with triple points: `[ [ [ ... ] ] ]`  
         */
        fail : function (desc, annotation, result) {
            var sourceLine          = (result &amp;&amp; result.sourceLine) || (annotation &amp;&amp; annotation.sourceLine) || this.getSourceLine()
            
            if (annotation &amp;&amp; this.typeOf(annotation) != 'String') {
                if (!desc &amp;&amp; annotation.descTpl) desc = this.formatString(annotation.descTpl, annotation)
                
                var strings             = []
                
                var params              = annotation
                var annotation          = params.annotation
                var assertionName       = params.assertionName
                var hasGot              = params.hasOwnProperty('got')
                var hasNeed             = params.hasOwnProperty('need')
                var gotDesc             = params.gotDesc || 'Got'
                var needDesc            = params.needDesc || 'Need'
                
                if (!params.ownTextOnly &amp;&amp; (assertionName || sourceLine)) strings.push(
                    'Failed assertion ' + (assertionName ? '`' + assertionName + '` ' : '') + this.formatSourceLine(sourceLine)
                )
                
                if (hasGot &amp;&amp; hasNeed) {
                    var max         = Math.max(gotDesc.length, needDesc.length)
                    
                    gotDesc         = this.appendSpaces(gotDesc, max - gotDesc.length + 1)
                    needDesc        = this.appendSpaces(needDesc, max - needDesc.length + 1)
                }
                
                if (hasGot)     strings.push(gotDesc   + ': ' + Siesta.Util.Serializer.stringify(params.got))
                if (hasNeed)    strings.push(needDesc  + ': ' + Siesta.Util.Serializer.stringify(params.need))
                
                if (annotation) strings.push(annotation)
                
                annotation      = strings.join('\n')
            }
            
            if (result) {
                // Failing a pending waitFor operation
                result.name         = assertionName;
                result.passed       = false;
                result.annotation   = annotation;
                result.description  = desc;
            }
            
            this.addResult(result || new Siesta.Result.Assertion({
                name        : assertionName,
                passed      : false,
                sourceLine  : sourceLine,
            
                annotation  : annotation,
                description : desc
            }))

            if (this.harness.activateDebuggerOnFail) {
                eval(&quot;debugger&quot;);
            }

            if (this.harness.breakOnFail) {
                this.finalize(true);
                throw 'Assertion failed, test execution aborted';
            }
        },

        
        getSource : function () {
            return this.contentManager.getContentOf(this.url)
        },
        
        
        getSourceLine : function () {
            try {
                throw new Error()
            } catch (e) {
                if (e.stack) {
                    var match       = e.stack.match(this.urlExtractRegex())
                    
                    if (match) return match[ 1 ]
                }
                
                return null
            }
        },
        
        
        getStartTestAnchor : function () {
            return this.startTestAnchor
        },
        
        
        getExceptionCatcher : function () {
            return this.exceptionCatcher
        },
        
        
        getTestErrorClass : function () {
            return this.testErrorClass
        },

        
        processCallbackFromTest : function (callback, args, scope) {
            var me      = this

            if (!callback) return true;

            if (this.transparentEx) {
                callback.apply(scope || this.global, args || [])
            } else {
                var e = this.getExceptionCatcher()(function(){
                    callback.apply(scope || me.global, args || [])
                })
            
                if (e) {
                    this.failWithException(e)
                    
                    // flow should be interrupted - exception detected
                    return false
                }
            }
            
            // flow can be continued
            return true
        },

        
        getStackTrace : function (e) {
            if (Object(e) !== e)    return null
            if (!e.stack)           return null
            
            var text            = e.stack + '';
            var isFirefox       = /^@/.test(text)
            var lines           = text.split('\n')
            
            var result          = []
            var match
            
            for (var i = 0; i &lt; lines.length; i++) {
                if (!lines[ i ]) continue
                
                if (!i) {
                    if (isFirefox) 
                        result.push(e + '')
                    else {
                        result.push(lines[ i ])
                        continue;
                    }
                }
            
                if (isFirefox) {
                    match       = /@(.*?):(\d+)/.exec(lines[ i ]);
                    
                    // the format of stack trace in Firefox has changed, 080_exception_parsing should fail
                    if (!match) return null
                    
                    result.push('    at line ' + match[ 2 ] + ' of ' + match[ 1 ])
                } else {
                    match       = /\s*at\s(.*?):(\d+):(\d+)/.exec(lines[ i ]);
                    
                    // the format of stack trace in Chrome has changed, 080_exception_parsing should fail
                    if (!match) return null
                    
                    result.push('    at line ' + match[ 2 ] + ', character ' + match[ 3 ] + ', of ' + match[ 1 ])
                }
            }
                
            if (!result.length) return null
            
            return result
        },
        
        
        formatSourceLine : function (sourceLine) {
            return sourceLine ? 'at line ' + sourceLine + ' of ' + this.url : ''
        },
        
        
        appendSpaces : function (str, num) {
            var spaces      = ''
            
            while (num--) spaces += ' '
            
            return str + spaces
        },
        
        
        eachAssertion : function (func, scope) {
            scope       = scope || this
            
            this.getResults().each(function (result) {
                if (result instanceof Siesta.Result.Assertion) func.call(scope, result)
            })
        },
        
        
        eachSubTest : function (func, scope) {
            scope       = scope || this
            
            this.getResults().each(function (result) {
                if (result instanceof Siesta.Result.SubTest) func.call(scope, result.test)
            })
        },
        
        
        eachChildTest : function (func, scope) {
            scope       = scope || this
            
            this.getResults().eachChild(function (result) {
                if (result instanceof Siesta.Result.SubTest) func.call(scope, result.test)
            })
        },
        
        
        countKeys : function (object) {
            var counter = 0
            
            Joose.O.eachOwn(object, function () {
                counter++
            })
            
            return counter
        },
        
        
<span id='Siesta-Test-method-compareObjects'>        /**
</span>         * This method performs a deep comparison of the passed JSON objects. Objects must not contain cyclic references.
         * You can use this method in your own assertions.
         * 
         * @param {Mixed} obj1 The 1st object to compare
         * @param {Mixed} obj2 The 2nd object to compare
         * @param {Boolean} strict When passed the `true` value, the comparison of the primitive values will be performed with the 
         * `===` operator (so [ 1 ] and [ &quot;1&quot; ] object will be different). Additionally, when this flag is set to `true`, then
         * when comparing Function, RegExp and Date instances, additional check that objects contains the same set of own properties (&quot;hasOwnProperty&quot;)
         * will be performed. 
         * @param {Boolean} onlyPrimitives When set to `true`, the function will not recurse into composite objects (like [] or {}) and will just report that
         * objects are different. Use this mode when you are only interesetd in comparison of primitive values (numbers, strings, etc).
         * @param {Boolean} asObjects When set to `true`, the function will compare various special Object instances, like Functions, RegExp etc,
         * by comparison of there properties only and not taking the anything else into account.
         * @return {Boolean} `true` if the passed objects are equal
         */
        compareObjects : function (obj1, obj2, strict, onlyPrimitives, asObjects) {
            var obj1IsPlaceholder       = Joose.O.isInstance(obj1) &amp;&amp; obj1.meta.does(Siesta.Test.Role.Placeholder)
            var obj2IsPlaceholder       = Joose.O.isInstance(obj2) &amp;&amp; obj2.meta.does(Siesta.Test.Role.Placeholder)
            
            if (strict) {
                if (obj1 === obj2) return true
            } else 
                if (obj1 == obj2) return true
                
            if (obj1IsPlaceholder &amp;&amp; obj2IsPlaceholder)
                return obj1.equalsTo(obj2)
            else if (obj2IsPlaceholder)
                return obj2.equalsTo(obj1)
            else if (obj1IsPlaceholder)
                return obj1.equalsTo(obj2)
                
            if (onlyPrimitives) return false
            
            var type1 = this.typeOf(obj1)
            var type2 = this.typeOf(obj2)
            
            if (type1 != type2) return false
            
            var me = this
                
            if (type1 == 'Object' || asObjects)
                if (this.countKeys(obj1) != this.countKeys(obj2)) 
                    return false
                else {
                    var res = Joose.O.eachOwn(obj1, function (value, name) {
                        
                        if (!me.compareObjects(value, obj2[ name ], strict)) return false
                    })
                    
                    return res === false ? false : true
                }
                
            if (type1 == 'Array')
                if (obj1.length != obj2.length) 
                    return false
                else {
                    for (var i = 0; i &lt; obj1.length; i++)
                        if (!this.compareObjects(obj1[ i ], obj2[ i ], strict)) return false
                    
                    return true
                }
                
            if (type1 == 'Function') 
                return obj1.toString() == obj2.toString() &amp;&amp; (!strict || this.compareObjects(obj1, obj2, strict, false, true))
            
            if (type1 == 'RegExp') 
                return obj1.source == obj2.source &amp;&amp; obj1.global == obj2.global &amp;&amp; obj1.ignoreCase == obj2.ignoreCase 
                    &amp;&amp; obj1.multiline == obj2.multiline &amp;&amp; (!strict || this.compareObjects(obj1, obj2, strict, false, true))
                
            if (type1 == 'Date') return !Boolean(obj1 - obj2) &amp;&amp; (!strict || this.compareObjects(obj1, obj2, strict, false, true))
            
            return false
        }, 
        
        
<span id='Siesta-Test-method-ok'>        /**
</span>         * This assertion passes when the supplied `value` evalutes to `true` and fails otherwise.
         *  
         * @param {Mixed} value The value, indicating wheter assertions passes or fails
         * @param {String} desc The description of the assertion
         */
        ok : function (value, desc) {
            if (value) 
                this.pass(desc, {
                    descTpl             : '`{value}` is a &quot;truthy&quot; value',
                    value               : value
                })
            else 
                this.fail(desc, {
                    assertionName       : 'ok', 
                    got                 : value, 
                    annotation          : 'Need &quot;truthy&quot; value'
                })
        },
        
        
        notok : function () {
            this.notOk.apply(this, arguments)
        },
        
<span id='Siesta-Test-method-notOk'>        /**
</span>         * This assertion passes when the supplied `value` evalutes to `false` and fails otherwise.
         * 
         * It has a synonym - `notok`.
         *  
         * @param {Mixed} value The value, indicating wheter assertions passes or fails
         * @param {String} desc The description of the assertion
         */
        notOk : function (value, desc) {
            if (!value) 
                this.pass(desc, {
                    descTpl             : '`{value}` is not a &quot;truthy&quot; value',
                    value               : value
                })
            else 
                this.fail(desc, {
                    assertionName       : 'notOk', 
                    got                 : value, 
                    annotation          : 'Need &quot;falsy&quot; value'
                })
        },
        
        
<span id='Siesta-Test-method-is'>        /**
</span>         * This assertion passes when the comparison of 1st and 2nd arguments with `==` operator returns true and fails otherwise.
         * 
         * As a special case, one or both arguments can be *placeholders*, generated with method {@link #any}. 
         * 
         * @param {Mixed} got The value &quot;we have&quot; - will be shown as &quot;Got:&quot; in case of failure
         * @param {Mixed} expected The value &quot;we expect&quot; - will be shown as &quot;Need:&quot; in case of failure
         * @param {String} desc The description of the assertion
         */
        is : function (got, expected, desc) {
            if (expected &amp;&amp; got instanceof this.global.Date) {
                this.isDateEqual(got, expected, desc);
            } else if (this.compareObjects(got, expected, false, true))
                this.pass(desc, {
                    descTpl             : '`{got}` is equal to `{expected}`',
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'is', 
                    got                 : got, 
                    need                : expected 
                })
        },
        

        
        isnot : function () {
            this.isNot.apply(this, arguments)
        },

        isnt : function () {
            this.isNot.apply(this, arguments)
        },
        
        
<span id='Siesta-Test-method-isNot'>        /**
</span>         * This assertion passes when the comparison of 1st and 2nd arguments with `!=` operator returns true and fails otherwise.
         * It has synonyms - `isnot` and `isnt`.
         * 
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         * 
         * @param {Mixed} got The value &quot;we have&quot; - will be shown as &quot;Got:&quot; in case of failure
         * @param {Mixed} expected The value &quot;we expect&quot; - will be shown as &quot;Need:&quot; in case of failure
         * @param {String} desc The description of the assertion
         */
        isNot : function (got, expected, desc) {
            if (!this.compareObjects(got, expected, false, true))
                this.pass(desc, {
                    descTpl             : '`{got}` is not equal to `{expected}`',
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isnt', 
                    got                 : got, 
                    need                : expected,
                    needDesc            : 'Need, not'
                })
        },
        

<span id='Siesta-Test-method-isStrict'>        /**
</span>         * This assertion passes when the comparison of 1st and 2nd arguments with `===` operator returns true and fails otherwise.
         * 
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         * 
         * @param {Mixed} got The value &quot;we have&quot; - will be shown as &quot;Got:&quot; in case of failure
         * @param {Mixed} expected The value &quot;we expect&quot; - will be shown as &quot;Need:&quot; in case of failure
         * @param {String} desc The description of the assertion
         */
        isStrict : function (got, expected, desc) {
            if (this.compareObjects(got, expected, true, true))
                this.pass(desc, {
                    descTpl             : '`{got}` is strictly equal to `{expected}`',
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isStrict', 
                    got                 : got, 
                    need                : expected,
                    needDesc            : 'Need strictly'
                })
        },

        
        isntStrict : function () {
            this.isNotStrict.apply(this, arguments)
        },
        
<span id='Siesta-Test-method-isNotStrict'>        /**
</span>         * This assertion passes when the comparison of 1st and 2nd arguments with `!==` operator returns true and fails otherwise.
         * It has synonyms - `isntStrict`.
         * 
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         * 
         * @param {Mixed} got The value &quot;we have&quot; - will be shown as &quot;Got:&quot; in case of failure
         * @param {Mixed} expected The value &quot;we expect&quot; - will be shown as &quot;Need:&quot; in case of failure
         * @param {String} desc The description of the assertion
         */
        isNotStrict : function (got, expected, desc) {
            if (!this.compareObjects(got, expected, true, true))
                this.pass(desc, {
                    descTpl             : '`{got}` is not strictly equal to `{expected}`',
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isntStrict', 
                    got                 : got, 
                    need                : expected,
                    needDesc            : 'Need, strictly not'
                })
        },
        
        
<span id='Siesta-Test-method-wait'>        /**
</span>         * This method starts the &quot;asynchronous frame&quot;. The test will wait for all asynchronous frames to complete before it will finalize.
         * The frame can be finished with the {@link #endWait} call. Unlike the {@link #beginAsync}, this method requires you to provide
         * the unique id for the asynchronous frame. 
         * 
         * For example:
         * 
         *      t.wait(&quot;require&quot;)
         *      
         *      Ext.require('Some.Class', function () {
         *      
         *          t.ok(Some.Class, 'Some class was loaded')
         *          
         *          t.endWait(&quot;require&quot;)
         *      })
         * 
         * 
         * @param {String} title The unique id for the asynchronous frame.
         * @param {String} howLong The maximum time (in ms) to wait until force the finalization of this async frame. Optional. Default time is 15000 ms.
         */
        wait : function (title, howLong) {
            if (this.waitTitles.hasOwnProperty(title)) throw new Error(&quot;Already doing a `wait` with title [&quot; + title + &quot;]&quot;)
            
            return this.waitTitles[ title ] = this.beginAsync(howLong)
        },
        
        
<span id='Siesta-Test-method-endWait'>        /**
</span>         * This method finalize the &quot;asynchronous frame&quot; started with {@link #wait}.
         * 
         * @param {String} title The id of frame to finalize, which was previously passed to {@link #wait} method
         */
        endWait : function (title) {
            if (!this.waitTitles.hasOwnProperty(title)) throw new Error(&quot;There were no call to `wait` with title [&quot; + title + &quot;]&quot;)
            
            this.endAsync(this.waitTitles[ title ])
            
            delete this.waitTitles[ title ]
        },
        
        
        
<span id='Siesta-Test-method-beginAsync'>        /**
</span>         * This method starts the &quot;asynchronous frame&quot;. The test will wait for all asynchronous frames to complete before it will finalize.
         * The frame should be finished with the {@link #endAsync} call within the provided `time`, otherwise a failure will be reported. 
         * 
         * For example:
         * 
         *      var async = t.beginAsync()
         *      
         *      Ext.require('Some.Class', function () {
         *      
         *          t.ok(Some.Class, 'Some class was loaded')
         *          
         *          t.endAsync(async)
         *      })
         * 
         * 
         * @param {Number} time The maximum time (in ms) to wait until force the finalization of this async frame. Optional. Default time is 15000 ms.
         * @param {Function} errback Optional. The function to call in case the call to {@link #endAsync} was not detected withing `time`. If function
         * will return any &quot;truthy&quot; value, the failure will not be reported (you can report own failure with this errback).
         *  
         * @return {Object} The frame object, which can be used in {@link #endAsync} call
         */
        beginAsync : function (time, errback) {
            time                        = time || this.defaultTimeout
            
            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout
            
            var index                   = this.timeoutsCount++
            
            // in NodeJS `setTimeout` returns an object and not a simple ID, so we try hard to store that object under unique index
            // also using `setTimeout` from the scope of test - as timeouts in different scopes in browsers are mis-synchronized
            // can't just use `this.originalSetTimeout` because of scoping issues
            var timeoutId               = originalSetTimeout(function () {
                
                if (me.hasAsyncFrame(index)) {
                    if (!errback || !errback.call(me, me)) me.fail('No matching `endAsync` call within ' + time + 'ms')
                    
                    me.endAsync(index)
                }
            }, time)
            
            this.timeoutIds[ index ]    = timeoutId
            
            return index
        },
        
        
        hasAsyncFrame : function (index) {
            return this.timeoutIds.hasOwnProperty(index)
        },
        
        
<span id='Siesta-Test-method-endAsync'>        /**
</span>         * This method finalize the &quot;asynchronous frame&quot; started with {@link #beginAsync}.
         * 
         * @param {Object} frame The frame to finalize (returned by {@link #beginAsync} method
         */
        endAsync : function (index) {
            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout || this.global.clearTimeout
            var counter = 0
            
            if (index == null) Joose.O.each(this.timeoutIds, function (timeoutId, indx) {
                index = indx
                if (counter++) throw new Error(&quot;Calls to endAsync without argument should only be performed if you have single beginAsync statement&quot;) 
            })
            
            var timeoutId               = this.timeoutIds[ index ]
            
            // need to call in this way for IE &lt; 9
            originalClearTimeout(timeoutId)
            delete this.timeoutIds[ index ]
            
            var me = this
            
            if (this.processed &amp;&amp; !this.isFinished())
                // to allow potential call to `done` after `endAsync`
                originalSetTimeout(function () {
                    me.finalize()
                }, 1)
        },
        
        
        clearTimeouts : function () {
            var originalClearTimeout    = this.originalClearTimeout
            
            Joose.O.each(this.timeoutIds, function (value, id) {
                originalClearTimeout(value)
            })
            
            this.timeoutIds = {}
        },
        
        
        // deprecated
        skipIf : function (condition, why, code, howMany) {
            howMany = howMany || 1
            
            if (condition) {
                
                for (var i = 1; i &lt;= howMany; i++) this.addResult(new Siesta.Result.Assertion({
                    passed      : true,
                    isSkipped   : true,
                    
                    description : 'SKIPPED: ' + why
                }))    
                
            } else
                code()
        },
        
        
        // deprecated
        skip : function (why, code, howMany) {
            this.skipIf(true, why, code, howMany)
        },
        
        
        processSubTestConfig : function (config) {
            return Joose.O.extend({
                trait                   : Siesta.Test.Sub,
                
                parent                  : this,
                
                isTodo                  : this.isTodo,
                transparentEx           : this.transparentEx,
                
                waitForTimeout          : this.waitForTimeout,
                waitForPollInterval     : this.waitForPollInterval,
                defaultTimeout          : this.defaultTimeout,
                timeout                 : this.subTestTimeout,
                
                global                  : this.global,
                url                     : this.url,
                scopeProvider           : this.scopeProvider,
                harness                 : this.harness,
                generation              : this.generation,
                
                overrideSetTimeout      : false,
                originalSetTimeout      : this.originalSetTimeout,
                originalClearTimeout    : this.originalClearTimeout,
                
                autoCheckGlobals        : false,
                needToCleanup           : false
            }, config)            
        },
        
        
<span id='Siesta-Test-method-getSubTest'>        /**
</span>         * Returns a new instance of the test class, configured as being a &quot;sub test&quot; of the current test.
         * 
         * The number of nesting levels is not limited - ie sub-tests may have own sub-tests.
         * 
         * Note, that this method does not starts the sub test, but only instatiate it. To start the sub test, use {@link #launchSubTest} method. 
         * 
         * @param {String} name The name of the test. Will be used in the UI, as the parent node name in the assertions tree
         * @param {Function} code A function with test code. Will receive a test instance as the 1st argument. 
         * @param {Number} [timeout] A maximum duration (in ms) for this sub test. If test will not complete within this time, 
         * it will be considered failed. If not provided, the {@link Siesta.Harness#subTestTimeout} value is used. 
         * 
         * @return {Siesta.Test} A sub test instance
         */
        getSubTest : function (arg1, arg2, arg3) {
            var config
            
            if (arguments.length == 2 || arguments.length == 3) 
                config = {
                    name        : arg1,
                    run         : arg2,
                    timeout     : arg3
                } 
            else if (arguments.length == 1 &amp;&amp; this.typeOf(arg1) == 'Function') 
                config  = {
                    name        : 'Sub test',
                    run         : arg1
                }
            
            config              = config || arg1 || {}
            
            // pass-through only valid timeout values
            if (config.timeout == null) delete config.timeout
            
            var name            = config.name
            
            if (!config.run) {
                this.failWithException(&quot;Code body is not provided for sub test [&quot; + name + &quot;]&quot;)
                throw new Error(&quot;Code body is not provided for sub test [&quot; + name + &quot;]&quot;)
            }
            if (!config.run.length) {
                this.failWithException('Code body of sub test [' + name + '] does not declare a test instance as 1st argument')
                throw new Error('Code body of sub test [' + name + '] does not declare a test instance as 1st argument')
            }
            
            return new (config.meta || this.constructor)(this.processSubTestConfig(config))
        },
        
        
<span id='Siesta-Test-method-launchSubTest'>        /**
</span>         * This method launch the provided sub test instance.
         * 
         * @param {Siesta.Test} subTest A test instance to launch
         * @param {Function} callback A function to call, after the test is completed. This function is called regardless from the test execution result.
         */
        launchSubTest : function (subTest, callback) {
            var me          = this
            
            var async       = this.beginAsync(subTest.timeout || this.subTestTimeout, function () {
                me.fail('Subtest ' + (subTest.name ? '[' + subTest.name + ']' : '') +' failed to finish within ' + this.subTestTimeout + 'ms')
                
                testEndListener.remove()
                
                subTest.finalize(true)
                
                callback &amp;&amp; callback(subTest)
                
                return true
            })
            
            var testEndListener = subTest.on('testfinalize', function () {
                me.endAsync(async)
                
                callback &amp;&amp; callback(subTest)
            })
            
            this.addResult(subTest.getResults())
            
            subTest.start()
        },
        
        
<span id='Siesta-Test-method-todo'>        /**
</span>         * With this method you can mark a group of assertions as &quot;todo&quot;, assuming they most likely will fail,
         * but it's still worth to try to run them.
         * The supplied `code` function will be run, it will receive a new test instance as the 1st argument,
         * which should be used for assertion checks (and not the primary test instance, received from `StartTest`).
         * 
         * Assertions, failed inside of the `code` block will be still treated by harness as &quot;green&quot;.
         * Assertions, passed inside of the `code` block will be treated by harness as bonus ones and highlighted.
         *
         * See also {@link Siesta.Test.ExtJS#knownBugIn} method. Note, that this method will start a new {@link #subTest sub test}. 
         *
         * For example:

            t.todo('Scheduled for 4.1.x release', function (todo) {

                var treePanel    = new Ext.tree.Panel()

                todo.is(treePanel.getView().store, treePanel.store, 'NodeStore and TreeStore have been merged and there is only 1 store now');
            })

         * @param {String} why The reason/description for the todo
         * @param {Function} code A function, wrapping the &quot;todo&quot; assertions. This function will receive a special test class instance
         * which should be used for assertion checks
         */
        todo : function (why, code, callback) {
            if (this.typeOf(why) == 'Function') why = [ code, code = why ][ 0 ]
            
            var todo        = this.getSubTest({
                name            : why,
                
                run             : code,
                
                isTodo          : true,
                transparentEx   : false
            })

            this.launchSubTest(todo, callback)
        },
        
        
<span id='Siesta-Test-method-subTest'>        /**
</span>         * This method starts a new sub test. Sub tests have separate order of assertions. In the browser UI,
         * sub tests are presented with the &quot;parent&quot; node of the assertions tree. Sub tests are useful if you want to test
         * several asynchronous processes in parallel, and would like to see assertions from every process separated.
         * 
         * Sub tests may have their own sub tests, the number of nesting levels is not limited.
         * 
         * Sub test can contain asynchronous methods as any other tests. Sub tests are considered completed
         * only when all of its asynchronous methods have completed *and* all of its sub-tests are completed too.
         * 
         * For example:
         *

    t.subTest('Load 1st store', function (t) {
        var async   = t.beginAsync()
    
        store1.load({
            callback : function () {
                t.endAsync(async);
                t.isGreater(store1.getCount(), 0, &quot;Store1 has been loaded&quot;)
            }
        })
    })
    
    t.subTest('Load 2nd store', function (t) {
        var async   = t.beginAsync()
    
        store2.load({
            callback : function () {
                t.endAsync(async);
                t.isGreater(store2.getCount(), 0, &quot;Store2 has been loaded&quot;)
            }
        })
    })

         * Note, that sub test starts right away, w/o waiting for any previous sub tests to complete. If you'd like to run several sub-tests
         * sequentially, use {@link #chain} method in combination with {@link #getSubTest} method. 
         * 
         * @param {String} desc The name of the sub test. Will be shown as the name of the parent node in assertion tree.
         * @param {Function} code The test function to execute. It will receive a test instance as 1st argument. This test instance *must* be
         * used for assertions inside of the test function
         * @param {Function} callback The callback to execute after the sub test completes (either successfully or not)
         * @param {Number} [timeout] A maximum duration (in ms) for this sub test. If test will not complete within this time, 
         * it will be considered failed. If not provided, the {@link Siesta.Harness#subTestTimeout} value is used. 
         */
        subTest : function (desc, code, callback, timeout) {
            var subTest     = this.getSubTest({
                name            : desc || &quot;Sub test&quot;,
                
                timeout         : timeout,
                
                run             : code
            })

            this.launchSubTest(subTest, callback)
        },
        
        
        failWithException : function (e) {
            this.failed                 = true
            
            var stackTrace              = this.getStackTrace(e)
            var stringified             = e + ''
            var annotation              = (stackTrace || []).join('\n')

            this.failedException        = stringified
            this.failedExceptionType    = this.typeOf(e)
            
            // prepend the exception message to the stack trace if its not already there
            if (annotation.indexOf(stringified) == -1) annotation = stringified + annotation
            
            this.addResult(new Siesta.Result.Assertion({
                isException     : true,
                exceptionType   : this.failedExceptionType,
                passed          : false,
                description     : (this.parent ? &quot;Sub-test `&quot; + this.name + &quot;`&quot; : 'Test ') + ' threw an exception',
                annotation      : annotation
            }))
            
            
<span id='Siesta-Test-event-testfailedwithexception'>            /**
</span>             * This event is fired when an individual test case has thrown an exception.
             * 
             * This event bubbles up to the {@link Siesta.Harness harness}, so you can observe it on the harness as well.
             * 
             * @event testfailedwithexception
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just threw an exception
             * @param {Object} exception The exception thrown
             */
            this.fireEvent('testfailedwithexception', this, e, stackTrace);
            
            this.finalize(true)
        },
        
        
        start : function (alreadyFailedWithException) {
            if (this.startDate) {
                throw 'Test has already been started';
            }

            this.startDate  = new Date() - 0
            
<span id='Siesta-Test-event-teststart'>            /**
</span>             * This event is fired when an individual test case starts. When *started*, the test may still be waiting for the {@link #isReady} condition
             * to be fullfilled. Once all conditions are fullfilled the test will be *launched*.
             * 
             * This event bubbles up to the {@link Siesta.Harness harness}, you can observe it on harness as well. 
             * 
             * @event teststart
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has started
             */
            this.fireEvent('teststart', this);
            
            if (alreadyFailedWithException) {
                this.failWithException(alreadyFailedWithException) 
                
                return
            }
            
            if (this.parent) {
                this.launch()
                return
            }
            
            var me              = this;
            var errorMessage; 
            var readyRes        = me.isReady();
            
            // Note, that `setTimeout, setInterval` and similar methods here are from the harness context
            
            var cont            = function (isReadyError) {
                var hasTimedOut     = false
                
                var setupTimeout    = setTimeout(function () {
                    hasTimedOut     = true
                    me.launch('`setup` method took too long to complete')
                }, me.isReadyTimeout)
                
                me.setup(
                    function () {
                        if (!hasTimedOut) {
                            clearTimeout(setupTimeout)
                            me.launch()
                        }
                    },
                    function (setupError) {
                        if (!hasTimedOut) {
                            clearTimeout(setupTimeout)
                            me.launch(setupError)
                        }
                    }
                );
            }
            
            if (readyRes.ready) {
                // We're ready to go
                cont();
            } else {
                // Need to wait for isReady to give green light
                var timeout         = setTimeout(function () {
                    clearInterval(interval)
                    cont(errorMessage)
                    
                }, me.isReadyTimeout)
                
                var interval = setInterval(function(){ 
                    readyRes = me.isReady();
                
                    if (readyRes.ready) {
                        clearInterval(interval)
                        clearTimeout(timeout)
                        cont();
                    } else {
                        errorMessage = readyRes.reason || errorMessage;
                    }
                }, 100);
            }
        },
        
        
<span id='Siesta-Test-method-setup'>        /**
</span>         * This method can perform any setup code your tests need. It is called before the begining of every test and receives
         * a callback and errback, which should be called once the setup has completed. Typical usage for this method can be for example
         * to log in into the application, before interacting with it:
         * 

    Class('My.Test.Class', {
        
        isa         : Siesta.Test.Browser,
            
        override : {
            
            setup : function (callback, errback) {
                Ext.Ajax.request({
                    url     : 'do_login.php',
                    
                    params  : { ... },
                    
                    success : function () {
                        callback()
                    },
                    failure : function () {
                        errback('Login failed')
                    }
                })
            }
        },
        
        ....
    })

         * 
         * This method will be called *after* the {@link #isReady} method has reported that test is ready for start.
         * 
         * If setup has failed for some reason, then a errback should be called and failing assertion will be added to the test
         * (test will be lauched anyway). A text of the failed assertion can be given as the 1st argument for the errback.
         * 
         * Note, that setup is supposed to be completed within the {@link #isReadyTimeout} timeout, otherwise it will be 
         * considered failed and test will be launched with failed assertion.
         * 
         * @param {Function} callback A function to call when setup has completed successfully
         * @param {Function} errback A function to call when setup has completed with an error
         */
        setup : function (callback, errback) {
            callback.call(this)
        },
            

        launch : function (errorMessage) {
            if (errorMessage) {
                this.fail('Error happened even before the test has started', {
                    annotation      : errorMessage
                })
            }
            
            var me                      = this
            var global                  = this.global
            
            var scopeProvider           = this.scopeProvider
            
            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout
            
            // this.overrideSetTimeout
            if (this.overrideSetTimeout) {
                // see http://www.adequatelygood.com/2011/4/Replacing-setTimeout-Globally
                scopeProvider.runCode('var setTimeout, clearTimeout;')
                
                global.setTimeout = function (func, delay) {
                    
                    var index = me.timeoutsCount++
                    
                    // in NodeJS `setTimeout` returns an object and not a simple ID, so we try hard to store that object under unique index
                    // also using `setTimeout` from the scope of test - as timeouts in different scopes in browsers are mis-synchronized
                    var timeoutId = originalSetTimeout(function () {
                        originalClearTimeout(timeoutId)
                        delete me.timeoutIds[ index ]
                        
                        // if the test func has been executed, but the test was not finalized yet - then we should try to finalize it
                        if (me.processed &amp;&amp; !me.isFinished())
                            // we are doing that after slight delay, potentially allowing to setup some other async frames in the &quot;func&quot; below
                            originalSetTimeout(function () {
                                me.finalize()
                            }, 1)
                        
                        func()
                        
                    }, delay)
    
                    // in NodeJS saves the index of the timeout descriptor to the descriptor
                    if (typeof timeoutId == 'object') 
                        timeoutId.__index = index
                    else
                        // in browser (where `timeoutId` is a number) - to the `idsToIndex` hash
                        me.idsToIndex[ timeoutId ] = index
                        
                    return me.timeoutIds[ index ] = timeoutId
                }
                
                global.clearTimeout = function (id) {
                    if (id == null) return
                    
                    var index
                    
                    // in NodeJS `setTimeout` returns an object and not a simple ID
                    if (typeof id == 'object') {
                        index       = id.__index
                        if (me.timeoutIds[ index ] != id) throw &quot;Incorrect state&quot;
                    } else {
                        index       = me.idsToIndex[ id ]
                        
                        delete me.idsToIndex[ id ]
                    }
                    
                    originalClearTimeout(id)
                    
                    if (index != null) delete me.timeoutIds[ index ]
                    
                    // if the test func has been executed, but the test was not finalized yet - then we should try to finalize it
                    if (me.processed &amp;&amp; !me.isFinished())
                        // we are doing that after slight delay, potentially allowing to setup some other async frames after the &quot;clearTimeout&quot; will complete
                        originalSetTimeout(function () {
                            me.finalize()
                        }, 1)
                }
            }
            // eof this.overrideSetTimeout
            
            // we only don't need to cleanup up when doing a self-testing or for sub-tests
            if (this.needToCleanup) {
                scopeProvider.beforeCleanupCallback = function () {
                    // if scope cleanup happens most probably user has restarted the test and is not interested in the results
                    // of previous launch
                    // finalizing the previous test in such case
                    if (!me.isFinished()) me.finalize(true)
                    
                    if (me.overrideSetTimeout) {
                        global.setTimeout       = originalSetTimeout
                        global.clearTimeout     = originalClearTimeout
                    }
                    
                    // cleanup the closures just in case (probably useful for IE)
                    originalSetTimeout          = originalClearTimeout  = null
                    global                      = run                   = null
                    
                    me.eachSubTest(function (subTest) {
                        subTest.cleanup()
                    })
                }
            }
            
            var run     = this.run
            
            if (this.transparentEx)
                run(me)
            else 
                var e = this.getExceptionCatcher()(function(){
                    run(me)
                })
            
            this.afterLaunch(e)
        },
        
        
        cleanup : function () {
            this.originalSetTimeout     = this.originalClearTimeout     = null
            this.global                 = this.run                      = null
            this.exceptionCatcher       = this.testErrorClass           = null
            this.startTestAnchor                                        = null
        },
        
        
        // a method executed after the &quot;run&quot; function has been ran - used in BDD role for example
        afterLaunch : function (e) {
            if (e)
                this.failWithException(e)
            else
                this.finalize()
        },
        
        
        finalize : function (force) {
            if (this.isFinished()) return
            
            this.processed = true
            
            if (force) {
                this.clearTimeouts()
                
                this.eachChildTest(function (childTest) { childTest.finalize(true) })
            }
            
            if (!Joose.O.isEmpty(this.timeoutIds)) {
                if (
                    !this.__timeoutWarning &amp;&amp; this.overrideSetTimeout &amp;&amp; this.lastActivityDate &amp;&amp;
                    new Date() - this.lastActivityDate &gt; this.defaultTimeout * 2
                ) {
                    this.diag('Your test is still considered to be running, if this is unexpected please see console for more information');
                    this.warn('Your test [' + this.url + '] has not finalized, most likely since a timer (setTimeout) is still active. ' + 
                              'If this is the expected behavior, try setting &quot;overrideSetTimeout : false&quot; on your Harness configuration.');
                    this.__timeoutWarning = true;
                }

                return
            }

            if (!this.needDone &amp;&amp; !this.isDone) {
                // this is early &quot;testfinalize&quot; hook, we need &quot;early&quot; and &quot;usual&quot; hooks, since we want globals check to be the last assertion
                this.fireEvent('beforetestfinalizeearly', this)

                if (!force &amp;&amp; !Joose.O.isEmpty(this.timeoutIds)) {
                    // Firing the beforetestXXX events may trigger additional test actions
                    return;
                }

<span id='Siesta-Test-event-beforetestfinalize'>                /**
</span>                 * This event is fired before the individual test case ends (no any corresponded harness actions will be run yet).
                 * 
                 * This event bubbles up to the {@link Siesta.Harness harness}, you can observe it on harness as well.
                 * 
                 * @event beforetestfinalize
                 * @member Siesta.Test
                 * @param {JooseX.Observable.Event} event The event instance
                 * @param {Siesta.Test} test The test instance that is about to finalize
                 */
                this.fireEvent('beforetestfinalize', this);
            }
            
            this.endDate = new Date() - 0

            if (!this.parent) this.addResult(new Siesta.Result.Summary({
                isFailed            : this.isFailed(),
                description         : this.getSummaryMessage()
            }))
            
<span id='Siesta-Test-event-testfinalize'>            /**
</span>             * This event is fired when an individual test case ends (either because it has completed correctly or thrown an exception).
             * 
             * This event bubbles up to the {@link Siesta.Harness harness}, you can observe it on the harness as well.
             * 
             * @event testfinalize
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has completed
             */
            this.fireEvent('testfinalize', this);
            
            // a test end event that bubbles
            this.fireEvent('testendbubbling', this);
            
            this.callback &amp;&amp; this.callback()
        },
        
        
        getSummaryMessage : function (lineBreaks) {
            var res             = []
            
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned
            var total           = failCount + passCount
            
            res.push('Passed: ' + passCount)
            res.push('Failed: ' + failCount)
            
            if (!this.failed) {
                // there was a t.plan() call
                if (assertPlanned != null) {
                    if (total &lt; assertPlanned) 
                        res.push('Looks like you planned ' + assertPlanned + ' tests, but ran only ' + total)
                        
                    if (total &gt; assertPlanned) 
                        res.push('Looks like you planned ' + assertPlanned + ' tests, but ran ' +  (total - assertPlanned) + ' extra tests, ' + total + ' total.')
                    
                    if (total == assertPlanned &amp;&amp; !failCount) res.push('All tests passed')
                } else {
                    if (!this.isDoneCorrectly()) res.push('Test has completed, but there were no `t.done()` call. Add it at the bottom, or use `t.beginAsync()` for asynchronous code')
                    
                    if (this.isDoneCorrectly() &amp;&amp; !failCount) res.push('All tests passed')
                }
            }
            
            return lineBreaks ? res.join(lineBreaks) : res
        },
        
        
<span id='Siesta-Test-method-done'>        /**
</span>         * This method indicates that test has completed at the expected point and no more assertions are planned. Adding assertions after the call to `done`
         * will add a failing assertion &quot;Adding assertion after test completion&quot;.
         * 
         * @param {Number} delay Optional. When provided, the test will not complete right away, but will wait for `delay` milliseconds for additional assertions. 
         */
        done : function (delay) {
            var me      = this
            
            if (delay) {
                var async = this.beginAsync()
                
                var originalSetTimeout = this.originalSetTimeout
                
                originalSetTimeout(function () {
                    
                    me.endAsync(async)
                    me.done() 
                
                }, delay)
                
            } else {
                this.fireEvent('beforetestfinalizeearly')
                this.fireEvent('beforetestfinalize');
                
                this.isDone = true
                
                if (this.processed) this.finalize()
            }
        },
        
        // `isDoneCorrectly` means that either test does not need the call to `done`
        // or the call to `done` has been already made
        isDoneCorrectly : function () {
            return !this.needDone || this.isDone
        },
        
        
        getAssertionCount : function (excludeTodo) {
            var count   = 0
            
            this.eachAssertion(function (assertion) {
                if (!excludeTodo || !assertion.isTodo) count++
            })
            
            return count
        },
        
        
        // cached method except the &quot;includeTodo&quot; case
        getPassCount : function (includeTodo) {
            if (this.$passCount != null &amp;&amp; !includeTodo) return this.$passCount
            
            var passCount = 0
            
            this.eachAssertion(function (assertion) {
                if (assertion.passed &amp;&amp; (includeTodo || !assertion.isTodo)) passCount++
            })
            
            return includeTodo ? passCount : this.$passCount = passCount
        },

        getTodoPassCount : function () {
            var todoCount = 0;
            
            this.eachAssertion(function (assertion) {
                if (assertion.isTodo &amp;&amp; assertion.passed) todoCount++;
            });
            
            return todoCount;
        },

        getTodoFailCount : function () {
            var todoCount = 0;
            
            this.eachAssertion(function (assertion) {
                if (assertion.isTodo &amp;&amp; !assertion.passed) todoCount++;
            });
            
            return todoCount;
        },
        
        
        // cached method except the &quot;includeTodo&quot; case
        getFailCount : function (includeTodo) {
            if (this.$failCount != null &amp;&amp; !includeTodo) return this.$failCount
            
            var failCount = 0
            
            this.eachAssertion(function (assertion) {
                if (!assertion.passed &amp;&amp; (includeTodo || !assertion.isTodo)) failCount++
            })
            
            return includeTodo ? failCount : this.$failCount = failCount
        },
        
        
        getFailedAssertions : function () {
            var failed      = [];
            
            this.eachAssertion(function (assertion) {
                if (!assertion.isPassed()) failed.push(assertion)
            })
            
            return failed
        },
        
        
        isPassed : function () {
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned
            
            return this.isFinished() &amp;&amp; !this.failed &amp;&amp; !failCount &amp;&amp; (
                assertPlanned != null &amp;&amp; passCount == assertPlanned
                    ||
                assertPlanned == null &amp;&amp; this.isDoneCorrectly()
            )
        },
        
        
        isFailed : function () {
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned
            
            return this.failed || failCount || (
            
                this.isFinished() &amp;&amp; ( 
                    assertPlanned != null &amp;&amp; passCount != assertPlanned
                        ||
                    assertPlanned == null &amp;&amp; !this.isDoneCorrectly()
                )
            )
        },
        
        
        isFailedWithException : function () {
            return this.failed
        },
        
        
        isStarted : function () {
            return this.startDate != null
        },
        
        
        isFinished : function () {
            return this.endDate != null
        },
        
        
        getDuration : function () {
            return this.endDate - this.startDate
        },
        
        
        getBubbleTarget : function () {
            return this.parent || this.harness;
        },
        
        
        warn : function (message) {
            this.addResult(new Siesta.Result.Diagnostic({
                description : message,
                isWarning   : true
            }))
        },
        
        
        flattenArray : function (array) {
            var me          = this
            var result      = []
            
            Joose.A.each(array, function (el) {
                if (me.typeOf(el) == 'Array') 
                    result.push.apply(result, me.flattenArray(el))
                else
                    result.push(el)
            })
            
            return result
        }
    }
    // eof methods
        
})
//eof Siesta.Test</pre>
</body>
</html>
